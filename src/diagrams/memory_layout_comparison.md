# メモリレイアウトの比較図

このドキュメントでは、様々なプログラミング言語のメモリレイアウトをASCIIアートとMermaid図で表現します。

## C言語のメモリレイアウト

```
┌─────────────────────────────────────┐ 高位アドレス
│         コマンドライン引数           │
│          環境変数                   │
├─────────────────────────────────────┤
│                                     │
│         スタック領域                │ ↓ 成長方向
│     (ローカル変数、戻り値)          │
│                                     │
├─────────────────────────────────────┤
│              ↓ ↑                   │
│         (未使用領域)                │
│              ↓ ↑                   │
├─────────────────────────────────────┤
│                                     │
│         ヒープ領域                  │ ↑ 成長方向
│      (動的割り当て)                 │
│                                     │
├─────────────────────────────────────┤
│      未初期化データ領域(BSS)         │
├─────────────────────────────────────┤
│      初期化済データ領域              │
├─────────────────────────────────────┤
│        テキスト領域                 │
│      (プログラムコード)             │
└─────────────────────────────────────┘ 低位アドレス
```

## Java/JVMのメモリレイアウト

```
┌─────────────────────────────────────┐
│         メタスペース                │
│    (クラスメタデータ、定数)         │
├─────────────────────────────────────┤
│                                     │
│      ヒープ領域                     │
│  ┌─────────────────────────────┐   │
│  │      Old Generation          │   │
│  │   (長寿命オブジェクト)       │   │
│  ├─────────────────────────────┤   │
│  │     Young Generation         │   │
│  │  ┌───────┬────────┬───────┐ │   │
│  │  │ Eden  │Survivor│Survivor│ │   │
│  │  │       │   S0   │   S1   │ │   │
│  │  └───────┴────────┴───────┘ │   │
│  └─────────────────────────────┘   │
│                                     │
├─────────────────────────────────────┤
│         スレッドスタック            │
│      (各スレッドごと)               │
│  ┌─────────────────────────────┐   │
│  │    ローカル変数              │   │
│  │    オペランドスタック        │   │
│  │    フレームデータ            │   │
│  └─────────────────────────────┘   │
├─────────────────────────────────────┤
│      プログラムカウンタ             │
│        レジスタ                     │
└─────────────────────────────────────┘
```

## Rustのメモリレイアウト

```
┌─────────────────────────────────────┐
│         スタック領域                │
│  ┌─────────────────────────────┐   │
│  │  所有権を持つ値              │   │
│  │  - プリミティブ型            │   │
│  │  - 構造体（インライン）      │   │
│  │  - 参照(&T, &mut T)          │   │
│  │  - Box<T>のポインタ部分      │   │
│  └─────────────────────────────┘   │
│                                     │
├─────────────────────────────────────┤
│         ヒープ領域                  │
│  ┌─────────────────────────────┐   │
│  │  Box<T>の実データ            │   │
│  │  Vec<T>の実データ            │   │
│  │  String の実データ           │   │
│  │  Rc<T>/Arc<T>の実データ      │   │
│  └─────────────────────────────┘   │
│                                     │
├─────────────────────────────────────┤
│      静的メモリ領域                 │
│  - 'static ライフタイム値           │
│  - const 定数                       │
│  - static 変数                      │
└─────────────────────────────────────┘
```

## 具体的な例：文字列のメモリレイアウト

### C言語の文字列

```
char str[] = "Hello";
char *ptr = "World";

スタック:
┌────────────────┐
│ str[0] = 'H'   │
│ str[1] = 'e'   │
│ str[2] = 'l'   │
│ str[3] = 'l'   │
│ str[4] = 'o'   │
│ str[5] = '\0'  │
├────────────────┤
│ ptr = 0x1234   │ → データ領域の "World\0" を指す
└────────────────┘
```

### Javaの文字列

```
String str = "Hello";

ヒープ:
┌────────────────────┐
│ String Object      │
│ ├─ value: char[]   │ → ┌─────────┐
│ ├─ hash: int       │   │ 'H'     │
│ └─ ...             │   │ 'e'     │
└────────────────────┘   │ 'l'     │
                          │ 'l'     │
                          │ 'o'     │
                          └─────────┘
```

### Rustの文字列

```
let s1 = "Hello";        // &str
let s2 = String::from("World");

スタック:                  静的領域/ヒープ:
┌────────────────┐        ┌─────────┐
│ s1:            │        │ "Hello" │ (静的領域)
│ ├─ ptr ────────┼────→   └─────────┘
│ └─ len = 5     │
├────────────────┤        ┌─────────┐
│ s2:            │        │ "World" │ (ヒープ)
│ ├─ ptr ────────┼────→   └─────────┘
│ ├─ len = 5     │
│ └─ cap = 5     │
└────────────────┘
```

## Mermaid図：所有権の転送

```mermaid
graph TD
    subgraph "関数 main()"
        A[String::from<br/>"Hello"]
        B[変数 s1<br/>所有権あり]
        A --> B
    end
    
    subgraph "関数 takes_ownership()"
        C[パラメータ s<br/>所有権を受け取る]
        D[スコープ終了<br/>メモリ解放]
        C --> D
    end
    
    B -->|move| C
    
    style B fill:#f9f,stroke:#333,stroke-width:2px
    style C fill:#9f9,stroke:#333,stroke-width:2px
    style D fill:#f99,stroke:#333,stroke-width:2px
```

## Box、Vec、Stringの内部構造

```
Box<T>:
スタック:        ヒープ:
┌─────────┐     ┌─────────┐
│ ptr ────┼──→  │ T の値  │
└─────────┘     └─────────┘

Vec<T>:
スタック:        ヒープ:
┌─────────┐     ┌─────────┐
│ ptr ────┼──→  │ T[0]    │
│ len     │     │ T[1]    │
│ cap     │     │ ...     │
└─────────┘     │ T[n-1]  │
                └─────────┘

String:
スタック:        ヒープ:
┌─────────┐     ┌─────────┐
│ ptr ────┼──→  │ UTF-8   │
│ len     │     │ bytes   │
│ cap     │     └─────────┘
└─────────┘
```

## Rc<T>とArc<T>の参照カウント

```
Rc<T>の構造:

ヒープ:
┌─────────────────┐
│ strong_count: 2 │
│ weak_count: 0   │
│ value: T        │
└─────────────────┘
      ↑         ↑
      │         │
┌─────┴───┐ ┌───┴─────┐
│ rc1     │ │ rc2     │
│ ptr ────┤ │ ptr ────┤
└─────────┘ └─────────┘
```

## スタックフレームの構造

```
関数呼び出し時のスタック:

高位アドレス
┌─────────────────────┐
│ 関数の引数          │
├─────────────────────┤
│ リターンアドレス    │
├─────────────────────┤ ← フレームポインタ(FP)
│ 前のFP              │
├─────────────────────┤
│ ローカル変数1       │
│ ローカル変数2       │
│ ...                 │
├─────────────────────┤ ← スタックポインタ(SP)
│ (次の関数用)        │
↓                     ↓
低位アドレス
```

## メモリアライメント

```
構造体のパディング:

struct Example {
    a: u8,    // 1 byte
    // padding: 3 bytes
    b: u32,   // 4 bytes
    c: u16,   // 2 bytes
    // padding: 2 bytes
}

メモリレイアウト:
┌───┬───────────┬───────┬───────┐
│ a │ padding   │   b   │   c   │ padding │
└───┴───────────┴───────┴───────┘
0   1           4       8      10        12
```

これらの図は、異なるプログラミング言語とRustにおけるメモリ管理の違いを視覚的に理解するのに役立ちます。